import sys
from typing import Annotated

from pydantic import BaseModel, Field

from cursed_vibing_on_the_fly import ai_implement

# Example 1: Primality
@ai_implement
def check_if_integer_is_prime(n: int) -> bool:
    """Check if n is a prime number."""
    pass

# Example 2: Even/Odd
@ai_implement
def check_is_odd(n: int) -> bool:
    """Check if the number is odd."""
    pass

# Example 3: Sum
@ai_implement
def calculate_sum(a: int, b: int) -> int:
    """Calculate the sum of two integers."""
    pass

# Example 4: Complex Types
class Point(BaseModel):
    x: float = Field(description="X coordinate")
    y: float = Field(description="Y coordinate")

class LineSegment(BaseModel):
    start: Point = Field(description="Starting point")
    end: Point = Field(description="Ending point")
    length: float = Field(description="Euclidean length of segment")

@ai_implement
def create_line_segment(
    p1: Annotated[Point, "First point"],
    p2: Annotated[Point, "Second point"],
) -> Annotated[
    LineSegment, "Line segment connecting the points with computed length"
]:
    """Create a line segment between two points, computing the length."""
    pass

def print_stats(func, name):
    if hasattr(func, "_ai_stats"):
        print(f"[{name}] Implementation attempts: {func._ai_stats['attempts']}")
    else:
        print(f"[{name}] Stats not available (maybe cached or manual mock?)")

if __name__ == "__main__":
    print("\n⚠️  WARNING ⚠️")
    print("This script will execute UNVERIFIED code generated by an LLM on your machine.")
    print("This is potentially dangerous. Ensure you are running this in a safe environment.")
    
    response = input("\nType 'continue' to proceed: ")
    if response.lower() != "continue":
        print("Aborting.")
        sys.exit(1)

    print("\n" + "=" * 60)
    print("TESTING AI-IMPLEMENTED FUNCTIONS")
    print("=" * 60)

    # 1. Primality
    print(f"\n1. Primality Test:")
    print(f"   Is 17 prime? {check_if_integer_is_prime(17)}")
    print(f"   Is 18 prime? {check_if_integer_is_prime(18)}")
    
    # Access the underlying function from the cache to get stats if using the decorator directly doesn't expose it easily
    # The decorator returns the result of the call, but tracks the function in _implementation_cache.
    # However, the wrapper is what we have here. 
    # To get stats, we need to inspect the function inside the cache or the one returned by the wrapper logic.
    # Wait, the wrapper calls the generated function. The generated function has ._ai_stats.
    # But `check_if_integer_is_prime` is the WRAPPER.
    # We need to peek into the cache to get the actual function object for stats.
    # We can import the cache for demo purposes or just rely on the fact that we can't easily see it from outside without exposing it.
    
    # Actually, let's just cheat and peek at the cache from the module for this demo
    from cursed_vibing_on_the_fly.core import _implementation_cache
    
    print_stats(_implementation_cache['check_if_integer_is_prime'], "check_if_integer_is_prime")


    # 2. Even/Odd
    print(f"\n2. Even/Odd Test:")
    print(f"   Is 3 odd? {check_is_odd(3)}")
    print(f"   Is 4 odd? {check_is_odd(4)}")
    print_stats(_implementation_cache['check_is_odd'], "check_is_odd")

    # 3. Sum
    print(f"\n3. Sum Test:")
    print(f"   10 + 20 = {calculate_sum(10, 20)}")
    print_stats(_implementation_cache['calculate_sum'], "calculate_sum")

    # 4. Complex Types
    print(f"\n4. Complex Types (Line Segment):")
    segment = create_line_segment(Point(x=0, y=0), Point(x=3, y=4))
    print(f"   Segment: {segment}")
    print(f"   Length: {segment.length}")  # Should be 5.0
    print_stats(_implementation_cache['create_line_segment'], "create_line_segment")
